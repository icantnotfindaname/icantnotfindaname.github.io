<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://icantnotfindaname.github.io</id>
    <title>Louispace</title>
    <updated>2021-09-11T08:31:32.926Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://icantnotfindaname.github.io"/>
    <link rel="self" href="https://icantnotfindaname.github.io/atom.xml"/>
    <subtitle>想做你的对手</subtitle>
    <logo>https://icantnotfindaname.github.io/images/avatar.png</logo>
    <icon>https://icantnotfindaname.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Louispace</rights>
    <entry>
        <title type="html"><![CDATA[构造二叉树]]></title>
        <id>https://icantnotfindaname.github.io/post/gou-zao-er-cha-shu/</id>
        <link href="https://icantnotfindaname.github.io/post/gou-zao-er-cha-shu/">
        </link>
        <updated>2021-09-11T07:25:16.000Z</updated>
        <summary type="html"><![CDATA[<p>这也是比较难的一个算法点，难点主要在于步骤有些繁复，且递归条件和区间开闭容易遗漏或者搞错。可以在力扣找到对应的题目。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这也是比较难的一个算法点，难点主要在于步骤有些繁复，且递归条件和区间开闭容易遗漏或者搞错。可以在力扣找到对应的题目。</p>
<!-- more -->
<h2 id="从中序和后序遍历序列构造二叉树">从中序和后序遍历序列构造二叉树</h2>
<p>不管是【中序 + 前序】还是【中序 + 后序】，其实思路都是一样的，大概分为以下几个步骤：</p>
<ol>
<li>通过后序（或者前序）序列找到树的根节点</li>
<li>通过中序序列确定根节点的左右子树</li>
<li>回过头来分割后序序列</li>
<li>递归处理左右区间</li>
</ol>
<p>这里理所应当该采用递归的算法，所以还要考虑一下递归的三个步骤，并且在进行数组分割的时候要考虑清楚区间的的开闭，在以下的代码中我选择了左开右闭的实现方式。</p>
<p>先给出伪代码：</p>
<pre><code class="language-C++">// is = start index of inorder, ie = end index of inorder ...... 
TreeNode* build(vector&lt;int&gt;&amp; inorder, int is, int ie, vector&lt;int&gt;&amp; postorder, int ps, int pe) {
    // return addition - 1
    if (pe == ps) return NULL;   // 因为是左闭右开，所以当 `pe == ps` 时数组中就已经没有任何节点了。

    // return addition - 2
    TreeNode* root = new TreeNode(postorder[pe - 1]);
    if (ps == pe - 1) return root;

    // find the dividing index
    // todo

    // divide inorder vector 
    // todo
    
    // divide preorder vector 
    // todo

    // ls_i 表示 left-start-inorder 中序序列左子树的起始索引，其他的依此类推
    root-&gt;left = build(inorder, ls_i, le_i, postorder, ls_p, le_p);
    root-&gt;right = build(inorder, rs_i, re_i, postorder, rs_p, re_p);
}
</code></pre>
<p>重点代码就在找到分割节点和分割两个数组这里了，代码如下：</p>
<pre><code class="language-C++">    // find the dividing index 
    int p;
    for (int p = is, p &lt; ie; p++) 
        if (inorder[p] == root-&gt;val)
            break;

    // divide inorder vector 
    ls_i = is;
    le_i = p;
    rs_i = p + 1;
    re_i = ie;

    // divide postorder vector 
    ls_p = ps;
    le_p = ps + p - is;
    rs_p = le_p;
    re_p = pe - 1;
</code></pre>
<p>首先根据一个循环在中序序列中找到根节点的索引，然后索引左边就是左子树，右边就是右子树；接下来开始切割后序序列，记中序序列分割得到的左子树中有 n 个节点，那么后序序列中的前 n 个节点就是左子树，剩下的节点就在右子树中。</p>
<p>这样整个递归函数就写完了，我们只需要在主函数中调用这个递归函数就可以了，代码如下：</p>
<pre><code class="language-C++">TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
    if (postorder.size() == 0 || inorder.size() == 0) return NULL;
    return build(inorder, 0, inorder.size(), postorder, 0, postorder.size());
}
</code></pre>
<h2 id="从中序和前序遍历序列构造二叉树">从中序和前序遍历序列构造二叉树</h2>
<p>如上所述，整个过程与【中序 + 后序】并没有什么区别。代码如下：</p>
<pre><code class="language-C++">TreeNode* build(vector&lt;int&gt;&amp; inorder, int is, int ie, vector&lt;int&gt;&amp; preorder, int ps, int pe) {
    if (ps == pe) return NULL;

    TreeNode* root = new TreeNode(preorder[ps]);
    if (pe == ps + 1) return root;

    int p;
    for (p = is; p &lt; ie; p++) 
        if (inorder[p] == root-&gt;val)
            break;
    
    // divide inorder 
    int ls_i = is;
    int le_i = p;
    int rs_i = p + 1;
    int re_i = ie;

    // divide preorder 
    int ls_p = ps + 1;
    int le_p = ps + 1 + p - is;
    int rs_p = le_p;
    int re_p = pe;

    root-&gt;left = build(inorder, ls_i, le_i, preorder, ls_p, le_p);
    root-&gt;right = build(inorder, rs_i, re_i, preorder, rs_p, re_p);

    return root;
}

TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; preorder) {
    if (inorder.size() == 0 || preorder.size() == 0) return NULL;
    return build(inorder, 0, inorder.size(), preorder, 0, preorder.size());
}
</code></pre>
<p>最后再注意一下以下几个点：</p>
<ol>
<li>区间的开闭</li>
<li>不要忘了返回值</li>
<li>注意递归的结束条件</li>
<li>参数太多不要混淆</li>
<li>没了</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归与回溯：以二叉树为例]]></title>
        <id>https://icantnotfindaname.github.io/post/di-gui-yu-hui-su-yi-er-cha-shu-wei-li/</id>
        <link href="https://icantnotfindaname.github.io/post/di-gui-yu-hui-su-yi-er-cha-shu-wei-li/">
        </link>
        <updated>2021-09-06T09:23:15.000Z</updated>
        <summary type="html"><![CDATA[<p>学了三年，还在写这种内容，唉…… 但不得不说，这是一个十分重要的基础问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>学了三年，还在写这种内容，唉…… 但不得不说，这是一个十分重要的基础问题。</p>
<!-- more -->
<p>这其实是力扣上的一道题：给定一个二叉树，找出其最大深度。</p>
<p>地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</p>
<h2 id="递归">递归</h2>
<p>递归有三个标准动作：</p>
<ol>
<li>确定函数参数以及返回的类型</li>
<li>确定递归的终止条件</li>
<li>确定单层递归的逻辑</li>
</ol>
<p>用上面的题为例：</p>
<ol>
<li>函数的参数当然就是 <code>TreeNode* root</code> 了，求最大深度，返回的类型就是 <code>int</code> 。</li>
<li>递归的终止条件就是 <code>root == NULL</code>，这个时候直接 <code>return 0</code> 。</li>
<li>单层的递归逻辑其实也很好想，其实就是得到左右子树的最大深度，然后比较之后挑一个比较大的，加上自己本身这一层就是当前接地点的最大深度。</li>
</ol>
<p>然后就可以写代码了：</p>
<pre><code class="language-C++">int maxDepth(TreeNode* root) {
    if (root == NULL) return 0;
    int left = maxDepth(root-&gt;left);
    int right = maxDepth(root-&gt;right);
    int res = left &gt; right ? left : right;
    return res + 1;
}
</code></pre>
<p>这就是一个完整的递归逻辑，最后还有一步就是简化代码（个人习惯，我喜欢首先确定逻辑无误之后再开始对代码进行简化处理，不知道其他人是怎么做的），简化之后的代码如下：</p>
<pre><code class="language-C++">int maxDepth(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));
}
</code></pre>
<p>注意以上都省略了结构体的编写以及 <code>#include</code> 部分，其中 <code>max</code> 函数位于 <code>#include&lt;algorithm&gt;</code> 中。</p>
<h2 id="回溯">回溯</h2>
<p>以上我们的做法其实是把求最大深度的问题转换成了求树的高度的问题，所以用的是后序遍历式的做法，但其实我们在求深度的时候用的应该是前序遍历式的算法，在前序遍历式算法中，为了达到类似递归的效果，我们就要使用回溯。<strong>回溯和递归是分不开的。</strong></p>
<p>那么上面的问题用前序遍历 + 回溯应该怎么做呢？代码如下：</p>
<pre><code class="language-C++">int result;
void getDepth(TreeNode *root, int depth) {
    result = depth &gt; result ? depth : result;
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return;
    if (root-&gt;left != NULL) {
        depth++;
        getDepth(root-&gt;left, depth);
        depth--;  // 回溯
    }
    if (root-&gt;right != NULL) {
        depth++;
        getDepth(root-&gt;right, depth);
        depth--;  // 回溯
    }
    return;
}
int maxDepth(TreeNode* root) {
    result = 0;
    if (root == NULL) return 0;
    getDepth(root, 1);
    return result;
}
</code></pre>
<p>这段代码需要注意两个点，一个是 <code>getDepth</code> 函数中的 <code>depth</code> 参数千万不能写成引用型，一个是注意在函数中是如何完成回溯的，在这里利用的是 <code>depth</code> 的增减。但有的时候回溯是没有这么明显的，会隐藏在函数体之中，比如上面的代码其实可以简化，如下所示：</p>
<pre><code class="language-C++">int result;
void getDepth(TreeNode* root, int depth) {
    result = depth &gt; result ? depth : result;
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; 
    if (root-&gt;left != NULL) getDepth(root-&gt;left, depth +1);  // 回溯在此
    if (root-&gt;right != NULL) getDepth(root-&gt;right, depth + 1);
    return;
}
int maxDepth(TreeNode* root) {
    result = 0;
    if (root == NULL) return 0;
    getDepth(root, 1);
    return result;
}
</code></pre>
<h2 id="总结">总结</h2>
<ol>
<li>递归的三大步骤</li>
<li>回溯的思想和写法</li>
<li>代码简化</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[补码浅析]]></title>
        <id>https://icantnotfindaname.github.io/post/bu-ma-qian-xi/</id>
        <link href="https://icantnotfindaname.github.io/post/bu-ma-qian-xi/">
        </link>
        <updated>2021-09-05T08:02:28.000Z</updated>
        <summary type="html"><![CDATA[<p>定点数的运算忘的差不多了，赶紧重新捡捡。</p>
]]></summary>
        <content type="html"><![CDATA[<p>定点数的运算忘的差不多了，赶紧重新捡捡。</p>
<!-- more -->
<h2 id="来源以及含义">来源以及含义</h2>
<p>补码的定义：给出长度为 n 的数值 y，则 y 的以基数 b 的补码为：b^n - y （即 b 的补码）</p>
<p>说补码首先就得说反码，因为反码是补码的一个过渡，二者的目的都在于改进计算机加减法运算的性能。当没有反码和补码的时候，减法虽然也可以转变成加法去进行运算，但是问题在于，比如，当你计算 1 - 1 的时候，用源码去计算的时候，就会变成 1 + -1 也就是 0001 + 1001，显然算出来根本不是 0。而且还有另外一个问题是用原码表示数字中有一个 +0 和一个 -0，这显然是毫无意义的。于是为了解决第一个问题，人们发明了反码。</p>
<p>反码：正数的反码和原码一样，负数的反码是符号位不变其它位取反。这样就解决了上面的第一个问题，上面的二进制加法用算出来就是  0001 + 1110 = 1111 正好是 -0 的反码，这样就得到了一个正确的结果。但第二个问题依然没有解决。</p>
<p>于是补码来了，这才是最终的解决形态，解决了上述的第二个问题。补码在二进制中就是反码加一，于是可以看到上述 -0 的反码加一之后变成了 10000，丢弃掉溢出的位之后就变成了 0000，刚好是 +0，完美解决。同时，由于只有一种 0 的表示方式，所以补码可以多表示一个负数。</p>
<p>另外，再从更宏观的计算考虑，也就是考虑开头的补码定义，在十进制中，55 - 50 在长度为 3 的情况下就可以写成 45 + 50 = 95 (这里丢弃掉了最高位) 补码刚好 5，得到了正确结果。那么这一切的原理是什么呢？</p>
<p>假设 x ＞ y，则 x - y = b^n - x + b^n + y = b^n - x + y 原码刚好就是 x - y 顺利回来了。</p>
<p>手推，但是我想这应该就是原理了吧。</p>
<h2 id="原码与补码之间的转换">原码与补码之间的转换</h2>
<p>整数的原码、反码、补码全部都是一样的，所以下面求补码的方法全部针对负数。</p>
<ol>
<li>使用定义求解</li>
<li>符号位不变，其他位取反后加1</li>
<li>符号位不变，最右边的1及其左边的数不变，其他位取反</li>
</ol>
<p>比如：</p>
<pre><code>原码：1000000
补码：1111111 + 1 = 10000000 溢出之后截断之后就变成

原码：1001100
补码：1110011 + 1 = 1110100
也可以直接用第三种方法：1 拼接 110 拼接 100 -&gt; 1110100
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP 算法]]></title>
        <id>https://icantnotfindaname.github.io/post/kmp-suan-fa/</id>
        <link href="https://icantnotfindaname.github.io/post/kmp-suan-fa/">
        </link>
        <updated>2021-09-03T08:34:48.000Z</updated>
        <summary type="html"><![CDATA[<p>这个算法堪称整个数据结构考研中最难的一个算法，第一次看的时候也是一脸懵逼。为了表达对它的敬意，写一篇文章集中解决ta。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个算法堪称整个数据结构考研中最难的一个算法，第一次看的时候也是一脸懵逼。为了表达对它的敬意，写一篇文章集中解决ta。</p>
<!-- more -->
<h3 id="next-数组的作用">next 数组的作用</h3>
<p>这个其实很好理解，next 数组就是为了避免像暴力匹配算法一样，一发现文本串与模式串不匹配就必须重置指针重新从头开始匹配。使用了 next 数组之后，文本串的指针可以不用回溯，所以搜索效率才可以达到 O(m) 其中 m 是文本串的长度。下面给出一个例子：</p>
<pre><code>文本串：aabaabaaf
模式串：aabaaf
</code></pre>
<p>首先两个字符串的指针都从头开始匹配，直到第六个字母的时候发现不匹配。这要是暴力匹配算法就会直接把文本串的指针退回指向第二个字符，模式串指针退回指向开始字符，然后重新开始尝试匹配。但是 KMP 算法就不一样了，本质其实是利用了已匹配字符串的信息，因为很明显模式串往右移一位显然还是不能匹配啊，所以就直接把模式串右移到以下位置：</p>
<pre><code>文本串：aabaabaaf
模式串：xxxaabaaf
</code></pre>
<p>从计算机的角度来说，实现这个效果的方法就是文本串指针保持不动，模式串指针退回指向第三个字符（b）然后继续往后匹配。</p>
<h3 id="next-数组的求法">next 数组的求法</h3>
<p>数组的值只与模式串有关而与文本串无关，next[i] 的含义为：i 包括 i 之前的子数组的<strong>最大相等前后缀的长度</strong>。这里还需要注意一下：前缀的含义是一个字符串除去最后一个字母之外的所有从第一个字母开始的连续字串，后缀也是差不多的道理。所以比如“aabaa”这个字串的最大相等前后缀就是“aa”，所以其最大相等前后缀长度就是 2；“aaaaa”这个字串的最大相等前后缀是“aaaa”，所以最大相等前后缀长度就是 4。以下是具体代码（C++）:</p>
<pre><code class="language-C++">void getNext(int *next, string s) {
    int j = 0;
    next[0] = 0;
    for (int i = 1; i &lt; s.size(); i++) {
        while (j &gt; 0 &amp;&amp; s[i] != s[j]) 
            j = next[j-1];  // 重点语句
        if (s[i] == s[j])
            ++j;
        next[i] = j;
    }
} 
</code></pre>
<p>前面首先对指针和数组进行初始化，重点语句是下面这句，如果新指向字符不匹配，就要重新回到上一个子串（不包含新字符）的最大相等字符长度，然后重新匹配。（这里说的不太清楚，请自行领悟，最好自己在纸上写一下）</p>
<h3 id="kmp-算法写法">KMP 算法写法</h3>
<p>求出 next 数组之后就好办了，每次匹配到不符合的时候，就找已经匹配完的子串的最大相等前后缀，也就是直接查 next 数组，然后把模式串的指针退回去继续匹配就行了。代码如下：</p>
<pre><code class="language-C++">int strStr(string s, string t) {
    if (t.size() == 0)
        return 0;
    int next[t.size()];
    getNext(next, t);
    int j = 0;
    for (int i = 0; i &lt; s.size(); i++) {
        while (j &gt; 0 &amp;&amp; s[i] != t[j]) 
            j = next[j - 1];
        if (s[i] == t[j])
            ++j;
        if (j == t.size())  // 注意这里的判断条件，不是 j == t.size() - 1
            return (i - t.size() + 1);
    }
    return -1;
}
</code></pre>
<p>结束。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历的非递归做法]]></title>
        <id>https://icantnotfindaname.github.io/post/er-cha-shu-bian-li-de-fei-di-gui-zuo-fa/</id>
        <link href="https://icantnotfindaname.github.io/post/er-cha-shu-bian-li-de-fei-di-gui-zuo-fa/">
        </link>
        <updated>2021-09-02T08:51:11.000Z</updated>
        <summary type="html"><![CDATA[<p>树这种结构，天生就适合用递归的做法来遍历，但是递归太容易了，考研不好考呀，没有区分度。于是出题老头们就开始把脑筋动到了非递归做法上。显而易见，能用递归来做那就肯定可以用循环来做，因为递归实际上就是一个栈的应用，我们只要在循环中引入栈就可以使循环达到向递归一样的效果。</p>
]]></summary>
        <content type="html"><![CDATA[<p>树这种结构，天生就适合用递归的做法来遍历，但是递归太容易了，考研不好考呀，没有区分度。于是出题老头们就开始把脑筋动到了非递归做法上。显而易见，能用递归来做那就肯定可以用循环来做，因为递归实际上就是一个栈的应用，我们只要在循环中引入栈就可以使循环达到向递归一样的效果。</p>
<!-- more -->
<p>但是在先、中、后序遍历中，使用循环实现的难度是不一样的，先序遍历和后序遍历会容易一些，但是中序遍历就稍稍有一定的难度了。原因后文再提。</p>
<p>首先看一下先序遍历的非递归写法：</p>
<pre><code class="language-C++">stack&lt;TreeNode*&gt; st;
void traversal_front_(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root == NULL) return; 
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        vec.push_back(node-&gt;val);
        if (node-&gt;right) st.push(node-&gt;right);
        if (node-&gt;left) st.push(node-&gt;left);
    }
}
</code></pre>
<p>首先根节点入栈，然后只要当栈不为空的时候就将栈顶弹出，把栈顶加到结果的 vector 数组中，然后将其左右孩子节点（如果有的话）放入栈中，注意这里有一个顺序问题，首先要入栈的是右节点，因为先进是后出的，我们要保证遍历的顺序是“中左右”。</p>
<p>后序遍历也是类似，不同之处在于我们首先将左孩子节点入栈然后才是右孩子节点，这样才能保证结果数组是按照“先右左”的顺序排列的，于是最后只要将整个数组逆过来，就可以得到后序遍历的正确结果。代码如下：</p>
<pre><code class="language-C++">void traversal_back_(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root == NULL) return;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        vec.push_back(node-&gt;val);
        if (node-&gt;left) st.push(node-&gt;left);
        if (node-&gt;right) st.push(node-&gt;right);
    }
    reverse(vec.begin(), vec.end());
}
</code></pre>
<p>但是中序遍历就没有这么容易的。问题的关键在于，我们在先序遍历和后序遍历中，<strong>待加到结果数组的节点和需要向下遍历的节点是同一个节点</strong>，所以我们用栈就可以同时实现这两个操作，但是在中序遍历中，上述两种操作的对象并不是同一个节点，所以我们就必须使用再加上一个辅助指针，用栈来处理节点，用指针来遍历树。代码如下：</p>
<pre><code class="language-C++">void traversal_mid_(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root == NULL) return;
    TreeNode* cur = root;
    while (cur != NULL || !st.empty()) {
        if (cur != NULL) {
            st.push(cur);
            cur = cur-&gt;left;
        } else {
            cur = st.top();
            st.pop();
            vec.push_back(cur-&gt;val);
            cur = cur-&gt;right;
        }
    }
}
</code></pre>
<p>首先循环条件就变了，只有当指针和栈同时为空的时候才会停止循环。在循环内，当指针不为空的时候，就把指针指向的节点压入栈中，然后将指针指向其左节点；如果指针为空的话，就要把栈顶弹出，加入结果数组中，然后将指针指向其右节点。</p>
<p>但这种写法又有一个问题了：<strong>三种遍历的写法不统一啊！<strong>对于强迫症患者来说，这真是一个天大的噩耗，但并不是没有解决办法的。核心思想是</strong>在已经可以加入结果数组的节点后面插入一个 NULL 节点作为标记</strong>。</p>
<p>于是中序遍历的代码就变成了这样：</p>
<pre><code class="language-C++">void traversal_mid__(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node-&gt;right) st.push(node-&gt;right);
            st.push(node);
            st.push(NULL);  // mark : ready to add to vector `vec` 
            if (node-&gt;left) st.push(node-&gt;left);
        } else {
            st.pop();  // pop the NULL node
            node = st.top();
            st.pop();
            vec.push_back(node-&gt;val);
        }
    }
}
</code></pre>
<p>重点在于注释的那两句，因为 node 已经访问了其左右孩子节点，所以已经可以加入 vec 了，所以插入一个 NULL 节点作为标识。当 node 为 NULL 时，就证明 NULL 的前驱已经准备好进组了，所以首先<strong>把 NULL 节点弹出</strong>（不要忘了这一步），然后把 node 加进结果数组中。</p>
<p>同样的道理，先序遍历和后序遍历也可以用此方法完成，不同的地方就是节点的进栈次序，其他都是一模一样的，代码如下：</p>
<pre><code class="language-C++">void traversal_front__(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node-&gt;right) st.push(node-&gt;right);
            if (node-&gt;left) st.push(node-&gt;left);
            st.push(node);
            st.push(NULL);  // mark : ready to add to vector `vec` 
        } else {
            st.pop();  // pop the NULL node
            node = st.top();
            st.pop();
            vec.push_back(node-&gt;val);
        }
    }
}

void traversal_back__(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);
            st.push(NULL);  // mark : ready to add to vector `vec`
            if (node-&gt;right) st.push(node-&gt;right);
            if (node-&gt;left) st.push(node-&gt;left);
        } else {
            st.pop();  // pop the NULL node
            node = st.top();
            st.pop();
            vec.push_back(node-&gt;val);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于福柯]]></title>
        <id>https://icantnotfindaname.github.io/post/guan-yu-fu-ke/</id>
        <link href="https://icantnotfindaname.github.io/post/guan-yu-fu-ke/">
        </link>
        <updated>2021-08-30T11:33:21.000Z</updated>
        <summary type="html"><![CDATA[<p>总有一天这会变成一篇完整的，用学术或文学话语铸就的，建立在断壁残垣的思想之上的文本。在福柯处，有一种如在其身的强烈共鸣。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总有一天这会变成一篇完整的，用学术或文学话语铸就的，建立在断壁残垣的思想之上的文本。在福柯处，有一种如在其身的强烈共鸣。</p>
<!-- more -->
<ol>
<li>对于边缘体验的过分追求 ❌ 但是在语言上，在除却身体之外的他处，是有道理的</li>
<li>知识考古学 ⭕</li>
<li>谱系学 这个理论吸引人的地方在于对现存理论话语的冲突，一种难以置信的正确感</li>
<li>权力 —— 在福柯处，本质是一种反抗，知识分子就是要对现有的权力体系进行质疑 —— 无论你是否身在其内。【我说：离经叛道是艺术家的责任，明辨是非是文学家的义务。无论什么时候，这都表现成一种激烈的斗争，一种对少数的体谅和对多数派的本能质疑，一种不间断的反思，无休止的自我扬弃】</li>
<li>人死了 ⭕ 强力的悲观，自尼采一脉相承而来</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[齐泽克: 西方自由主义媒体避而不谈的，塔利班迅速夺回阿富汗的真正原因]]></title>
        <id>https://icantnotfindaname.github.io/post/qi-ze-ke-xi-fang-zi-you-zhu-yi-mei-ti-bi-er-bu-tan-de-ta-li-ban-xun-su-duo-hui-a-fu-han-de-zhen-zheng-yuan-yin/</id>
        <link href="https://icantnotfindaname.github.io/post/qi-ze-ke-xi-fang-zi-you-zhu-yi-mei-ti-bi-er-bu-tan-de-ta-li-ban-xun-su-duo-hui-a-fu-han-de-zhen-zheng-yuan-yin/">
        </link>
        <updated>2021-08-20T05:25:59.000Z</updated>
        <summary type="html"><![CDATA[<p>齐泽克于2021年8月20日在 RT News 上发表了此篇文章，只能说，该来的终究会来。但基本只是老生常谈。</p>
]]></summary>
        <content type="html"><![CDATA[<p>齐泽克于2021年8月20日在 RT News 上发表了此篇文章，只能说，该来的终究会来。但基本只是老生常谈。</p>
<!-- more -->
<p>原文地址：https://www.rt.com/op-ed/532207-zizek-taliban-retake-afghanistan-reason/</p>
<p>以下为本人翻译：</p>
<p>塔利班的8万名士兵重新夺回了阿富汗，城市次第陷落，而披坚执锐的30万政府军却一触即溃，轻易投降。何以至此？</p>
<p>西方媒体告诉我们，对此可以有几种解释。</p>
<p>第一种是公然的种族主义歧视: 阿富汗人民思想不够健全，无力实现民主，只求宗教原教旨主义下的统治——这是个荒谬的主张。半个世纪前，阿富汗还是一个温和开明的国家，拥有一个强大的共产党（即阿富汗人民民主党，该党曾掌权数年），后方才成为宗教原教旨主义国家，这缘自苏联为避免其共产主义力量的崩溃而对阿富汗实行的入侵。</p>
<p>另一种解释是威慑，塔利班逆我者亡的恐怖行径导致无人敢于反抗。</p>
<p>还有一个解释是信仰。 塔利班只相信他们的行为是上帝的旨意，得上帝护佑，也注定会取得胜利，所以他们可以耐心蛰伏，待时而动，因为时间在他们这边。</p>
<p>另一个更加复杂而现实的解释是，不绝的战争和腐败造成的混乱可能会让阿富汗人民相信，即使塔利班政权实施压迫和伊斯兰教法式的统治，也至少可以保障最基本的安全和秩序。</p>
<p>然而，所有这些解释似乎都刻意回避了一个基本事实，这个事实对于自由主义的西方观点来说是创伤性的。这就是塔利班对个人生存的漠视，他们的战士们随时准备“殉教”，以战斗或自杀。塔利班作为原教旨主义者“真诚地相信”，如果他们作为殉道者死去，他们就能进入天堂。但是这种解释并不足够，因为它无法抓住知性洞察力意义上「belief in the sense of intellectual insight」的信仰（“我知道我会上天堂，这是一个事实”）与作为一种主观立场「belief as an engaged subjective position」的信仰之间的区别。</p>
<p>换句话说，<strong>它没有考虑到意识形态的实质力量——在此地是信仰的力量——这不单是信念的力量，而是一种生存论角度上的信仰：我们不作为选择信仰的主体，我们便是信仰，我们的生活浸润在信仰之中。</strong></p>
<p>正是如此，法国哲学家福柯才对1978年的伊斯兰革命情有独钟，这让他两度到访伊朗。让他着迷的不仅仅是乐于接受牺牲和对失去自己的生命漠不关心的立场; 他致力于细致入微地讲述“真相的历史”，强调激进党派与其激烈的真理讲述形式，以斗争和磨难来进行变革，而非现代西方权力那种调和、中立和正常化的形式。理解这种形式的关键在于，历史政治话语中的真理概念本就是一种局部的真理概念，是为党派保留的。</p>
<p>或者，正如福柯所述：</p>
<blockquote>
<p>如果这个主体谈论权利（或者母宁说他们的权利），谈论真理，那么这个真理就不再是哲学上的普遍真理。事实上，这个关于普遍战争的话语，试图从和平的下面分辨出战争的话语，就是要思实地讲述整体的战斗并构筑起战争的通史。但是，它并不就是全体性的或中性的话语；它永远是有视角的话语。仅仅在从它自己的角度出发透视全体性时，才涉及它。也就是说，真理仅仅只能从战斗的阵地出发，从争取胜利出发，可以说是在说话的主体得以幸存的范围内，才能得以展开。—— 《必须保卫社会》钱翰译</p>
</blockquote>
<p>这样一种侵入式的话语能否被视为尚未进入现代个人主义的前现代“原始”社会的标志而被摒弃呢？或者，今日它的复兴是否会被视为法西斯主义回归的标志？</p>
<p>对任何对西方马克思主义有所了解的人而言，答案是显而易见的: 匈牙利哲学家卢卡奇向我们展示了马克思主义是如何“普遍真实”的，不是因为它的不偏不倚，而正是因为它是“片面的”，只能从一个特定的主观立场来理解。我们可能同意或不同意这种观点，但事实是，福柯在遥远的伊朗所寻找的——竞争性的（“战争”）真相说明形式——已经在马克思主义的观点中有力地呈现出来，即，<strong>陷入阶级斗争不是对历史的“客观”知识的障碍，而是它的条件。</strong></p>
<p>通常意义上的实证主义知识，是对现实的一种“客观”（非片面）的方法，它不会被特定的主体参与所扭曲——而福柯所说的“现代西方权力的和谐化、中立化和正常化的形式”——是最纯粹的意识形态——也即“意识形态的终结”。</p>
<p>一方面，我们有非意识形态的“客观”的专家知识；而另一方面，我们分割了个体，使得每个人都专注于自己特有的“自我技术”(福柯放弃伊朗经历时使用的术语) ，沉溺于某些小事给他/她的生活带来的乐趣。</p>
<p>从自由个人主义的主流观点来看，一种普遍的承诺（译者注：我想作者的意思是一种宏观叙事），尤其包括对生命的风险的承诺，都是可疑的、“非理性的”。</p>
<p>在这里，我们遇到了一个有趣的悖论: 虽然传统的马克思主义能否令人信服地解释塔利班的成功奥秘是值得怀疑的，但它提供了福柯在伊朗寻找的东西（以及现在阿富汗令我们着迷的东西）的一个完美的欧洲范例，这个范例并不涉及任何宗教原教旨主义，只是为了更好的生活而进行的一种集体介入。在全球资本主义取得成功之后，这种集体参与的精神就受到了压制，而现在这种压制的立场似乎又在宗教原教旨主义的幌子下回归。</p>
<p>我们能否想象这种精神以一种更适当的，更有解放性的形式回归？当然。不仅可以想象，它已挟巨力敲响了我们的大门。</p>
<p>现在我们来讨论全球变暖这个灾难——它需要大规模的集体行动，需要所有人以某种程度上的殉难形式，牺牲许多我们早已习以为常的享乐。如果我们真的想彻底改变我们的生活方式，那么个人主义这种“自我关心”以获得特定快乐的方式就必须被替代。单靠专家式的科学是无法完成这项任务的——它必须是一门植根于最深刻的集体参与的社会科学。而这个，才是塔利班问题的答案。</p>
<p>( 全文完 )</p>
<h2 id="英文原版">英文原版</h2>
<p>The Taliban’s 80,000 troops have retaken Afghanistan with cities falling like dominos while the 300,000-strong government forces, better equipped and trained, mostly melted and surrendered with no will to fight. Why did it happen?</p>
<p>The Western media tell us there can be several explanations for that. The first one is blatantly racist: the Afghan people there are simply not mature enough for democracy, they long for religious fundamentalism – a ridiculous claim if there ever was one. Half a century ago, Afghanistan was a (moderately) enlightened country with a strong Communist Party known as the People’s Democratic Party of Afghanistan, which even managed to take power for some years. Afghanistan became religiously fundamentalist only later, as a reaction to the Soviet occupation which aimed to prevent the collapse of communist power.</p>
<p>Another explanation the media gives us is terror, as the Taliban ruthlessly executes those who oppose its politics.</p>
<p>A further one is faith: the Taliban simply believe their acts fulfill the task imposed on them by God and their victory is guaranteed. So, they can afford to be patient because time is on their side.</p>
<p>A more complex and realistic explanation as to why the Taliban managed to retake the country so promptly is chaos caused by the ongoing war and corruption. That could have caused a belief that even if the Taliban regime would bring oppression and impose Sharia Law, it would at least guarantee some safety and order.</p>
<p>However, all these explanations seem to avoid a basic fact that is traumatic for the liberal Western view. That is the Taliban’s disregard for survival and the readiness of its fighters to assume “martyrdom,” to die not just in a battle but even in suicidal acts. The explanation that Taliban as fundamentalists “really believe” that they will enter paradise if they die as martyrs is not enough as it fails to capture the difference between belief in the sense of intellectual insight (“I know I will go to heaven, it’s a fact”) and belief as an engaged subjective position.</p>
<p>In other words, it fails to take into account the material power of an ideology – in this case, the power of faith – which is not simply grounded in the strength of our conviction but in how we are existentially committed to our belief: we are not subjects choosing this or that belief, but we “are” our belief in the sense of this belief impregnating our life.</p>
<p>It was due to this feature that French philosopher Michel Foucault was so fascinated by the 1978 Islamic Revolution that he twice visited Iran. What fascinated him there was not just the stance of accepting martyrdom and indifference with regard to losing one’s own life; he was “engaged in a very specific telling of the ‘history of truth’, emphasizing a partisan and agonistic form of truth-telling, and transformation through struggle and ordeal, as opposed to the pacifying, neutralizing, and normalizing forms of modern Western power. Crucial for understanding this point is the conception of truth at work in historico-political discourse, a conception of truth as partial, as reserved for partisans.”</p>
<p>Or, as Foucault himself put it:</p>
<p>“If this subject who speaks of right (or rather, rights) is speaking the truth, that truth is no longer the universal truth of the philosopher. It is true that this discourse about the general war, this discourse that tries to interpret the war beneath peace, is indeed an attempt to describe the battle as a whole and to reconstruct the general course of the war. But that does not make it a totalizing or neutral discourse; it is always a perspectival discourse. It is interested in the totality only to the extent that it can see it in one-sided terms, distort it and see it from its own point of view. The truth is, in other words, a truth that can be deployed only from its combat position, from the perspective of the sought for victory and ultimately, so to speak, of the survival of the speaking subject himself.”</p>
<p>Can such an engaged discourse be dismissed as a sign of premodern “primitive” society which didn’t yet enter modern individualism? And is its revival today to be dismissed as a sign of fascist regression?</p>
<p>To anyone minimally acquainted with Western Marxism, the answer is clear: Hungarian philosopher Georg Lukacs demonstrated how Marxism is “universally true” not in spite of its partiality but because it is “partial,” accessible only from a particular subjective position. We may agree or disagree with this view, but the fact is that what Foucault was looking for in far-away Iran – the agonistic (“war”) form of truth-telling – was already forcefully present in the Marxist view that being caught in the class struggle is not an obstacle to “objective” knowledge of history but its condition.</p>
<p>The usual positivist notion of knowledge as an “objective” (non-partial) approach to reality which is not distorted by a particular subjective engagement – what Foucault characterized as “the pacifying, neutralizing, and normalizing forms of modern Western power” – is ideology at its purest – the ideology of the “end of ideology.”</p>
<p>On the one hand, we have non-ideological “objective” expert-knowledge. On the other hand, we have dispersed individuals, each of whom is focused on his/her idiosyncratic “care of the self” (the term Foucault used when he abandoned his Iranian experience), small things that bring pleasure to his/her life.</p>
<p>From this standpoint of liberal individualism, and universal commitment, especially if it includes risk of life, is suspicious and “irrational”…</p>
<p>Here we encounter an interesting paradox: while it is doubtful that traditional Marxism can provide a convincing account of the success of Taliban, it provided a perfect European example of what Foucault was looking for in Iran (and of what fascinates us now in Afghanistan), an example which did not involve any religious fundamentalism but just a collective engagement for a better life. After the triumph of global capitalism, this spirit of collective engagement was repressed, and now this repressed stance seems to return in the guise of religious fundamentalism.</p>
<p>Can we imagine a return of the repressed in its proper form of collective emancipatory engagement? Indeed. Not only can we imagine it, it is already knocking on our doors with great force.</p>
<p>Let’s just mention the global warming catastrophe – it calls for large-scale collective actions which will demand their own forms of martyrdom, sacrificing many pleasures we have got used to. If we really want to change our entire way of life, the individualist “care of the self” which focuses on our use of pleasures will have to be superseded. Expert science alone will not do the job – it will have to be a science rooted in the deepest collective engagement. THIS should be our answer to the Taliban.</p>
<p>( End )</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[齐泽克：分析哲学 vs 欧陆哲学]]></title>
        <id>https://icantnotfindaname.github.io/post/qi-ze-ke-fen-xi-zhe-xue-vs-ou-lu-zhe-xue/</id>
        <link href="https://icantnotfindaname.github.io/post/qi-ze-ke-fen-xi-zhe-xue-vs-ou-lu-zhe-xue/">
        </link>
        <updated>2021-08-20T03:55:34.000Z</updated>
        <summary type="html"><![CDATA[<p>对我而言，更为感兴趣的一点是齐泽克在视频后半部分提出的有趣观点：<strong>现实是未完成的</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>对我而言，更为感兴趣的一点是齐泽克在视频后半部分提出的有趣观点：<strong>现实是未完成的</strong>。</p>
<!-- more -->
<p>视频地址：https://www.bilibili.com/video/BV17341167ur?share_source=copy_web</p>
<iframe src="//player.bilibili.com/player.html?aid=419940997&bvid=BV17341167ur&cid=392866033&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何看懂生肉？]]></title>
        <id>https://icantnotfindaname.github.io/post/ru-he-kan-dong-sheng-rou/</id>
        <link href="https://icantnotfindaname.github.io/post/ru-he-kan-dong-sheng-rou/">
        </link>
        <updated>2021-08-19T02:42:44.000Z</updated>
        <summary type="html"><![CDATA[<p>这个短视频给了一个很简单有效的方法提升听力，但是我找不到原视频的地址了，文中提供的来源为tg群：黑洞资源笔记......</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个短视频给了一个很简单有效的方法提升听力，但是我找不到原视频的地址了，文中提供的来源为tg群：黑洞资源笔记......</p>
<!-- more -->
<p>在开始的时候，务必从一些简单难度的音频开始，接着逐渐加大难度，（如果难度过大，试着调低倍速）。当你发现你可以很轻松地听完整段材料时，不要满足于此，接着调高倍速进行练习。（可以听懂两倍速个人觉得就差不多了）</p>
<p>视频地址：https://t.me/tieliu/14572</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nextcloud 安装笔记]]></title>
        <id>https://icantnotfindaname.github.io/post/nextcloud-an-zhuang-bi-ji/</id>
        <link href="https://icantnotfindaname.github.io/post/nextcloud-an-zhuang-bi-ji/">
        </link>
        <updated>2021-08-18T02:41:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Nextcloud是ownCloud的创始人Frank Karlitschek创建的一个分支，他与原先ownCloud的一些团队成员继续开发Nextcloud，同时也成立了一家商业化公司，其目标就是将数据和通讯的控制权归还给用户。直到2019年初，Nextcloud已成为最受欢迎的私有云盘之一（下图所示）。与此同时，也有越来越多的开发者涌入社区，为Nextcloud开发了许多的应用插件......</p>
]]></summary>
        <content type="html"><![CDATA[<p>Nextcloud是ownCloud的创始人Frank Karlitschek创建的一个分支，他与原先ownCloud的一些团队成员继续开发Nextcloud，同时也成立了一家商业化公司，其目标就是将数据和通讯的控制权归还给用户。直到2019年初，Nextcloud已成为最受欢迎的私有云盘之一（下图所示）。与此同时，也有越来越多的开发者涌入社区，为Nextcloud开发了许多的应用插件......</p>
<!-- more -->
<p>Snap 是一个类似容器的东西，支持 CentOS7.6+，其他系统可以到 snap 的官网进行查看。</p>
<p><a href="https://snapcraft.io/install/nextcloud/centos">Install Nextcloud on CentOS using the Snap Store | Snapcraft</a></p>
<p>下载命令如下：</p>
<pre><code class="language-bash">sudo yum install epel-release
sudo yum install snapd
sudo systemctl enable --now snapd.socket
sudo ln -s /var/lib/snapd/snap /snap
sudo snap install nextcloud

// 以上已经下载完成
// 换端口
snap set nextcloud ports.http=60000

// https 配置SSL
nextcloud.enable-https lets-encrypt

// 创建软连接
ln -s /var/snap/nextcloud/common/nextcloud/data/louis/files /root/nextcloud
</code></pre>
<p>一些其他的命令可以查看官方 Github，可以解决 80% 的问题：</p>
<p><a href="https://github.com/nextcloud/nextcloud-snap">GitHub - nextcloud/nextcloud-snap: ☁️📦 Nextcloud packaged as a snap</a></p>
<p>或者官方文档：</p>
<p><a href="https://docs.nextcloud.com/server/latest/admin_manual/installation/#installation">Installation and server configuration - Nextcloud latest Administration Manual latest documentation</a></p>
<hr>
<p>2021.08.23 Update<br>
如果在服务器直接上传文件到 nextcloud 的 data 目录下，则需要手动扫描才可以在 web 上看到更新内容，推荐方法如下：</p>
<pre><code class="language-bash">vi /var/snap/nextcloud/28417/nextcloud/config/config.php  // 配置文件路径请自行确定

// 在最后一行添加
'filesystem_check_changes' =&gt; true,
</code></pre>
]]></content>
    </entry>
</feed>
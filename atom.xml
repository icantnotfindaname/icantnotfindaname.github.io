<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://icantnotfindaname.github.io</id>
    <title>Louispace</title>
    <updated>2021-09-03T09:10:28.773Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://icantnotfindaname.github.io"/>
    <link rel="self" href="https://icantnotfindaname.github.io/atom.xml"/>
    <subtitle>想做你的对手</subtitle>
    <logo>https://icantnotfindaname.github.io/images/avatar.png</logo>
    <icon>https://icantnotfindaname.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Louispace</rights>
    <entry>
        <title type="html"><![CDATA[KMP 算法]]></title>
        <id>https://icantnotfindaname.github.io/post/kmp-suan-fa/</id>
        <link href="https://icantnotfindaname.github.io/post/kmp-suan-fa/">
        </link>
        <updated>2021-09-03T08:34:48.000Z</updated>
        <summary type="html"><![CDATA[<p>这个算法堪称整个数据结构考研中最难的一个算法，第一次看的时候也是一脸懵逼。为了表达对它的敬意，写一篇文章集中解决ta。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个算法堪称整个数据结构考研中最难的一个算法，第一次看的时候也是一脸懵逼。为了表达对它的敬意，写一篇文章集中解决ta。</p>
<!-- more -->
<ol>
<li>next 数组的作用<br>
这个其实很好理解，next 数组就是为了避免像暴力匹配算法一样，一发现文本串与模式串不匹配就必须重置指针重新从头开始匹配。使用了 next 数组之后，文本串的指针可以不用回溯，所以搜索效率才可以达到 O(m) 其中 m 是文本串的长度。下面给出一个例子：</li>
</ol>
<pre><code>文本串：aabaabaaf
模式串：aabaaf
</code></pre>
<p>首先两个字符串的指针都从头开始匹配，直到第六个字母的时候发现不匹配。这要是暴力匹配算法就会直接把文本串的指针退回指向第二个字符，模式串指针退回指向开始字符，然后重新开始尝试匹配。但是 KMP 算法就不一样了，本质其实是利用了已匹配字符串的信息，因为很明显模式串往右移一位显然还是不能匹配啊，所以就直接把模式串右移到以下位置：</p>
<pre><code>文本串：aabaabaaf
模式串：     aabaaf
</code></pre>
<p>从计算机的角度来说，实现这个效果的方法就是文本串指针保持不动，模式串指针退回指向第三个字符（b）然后继续往后匹配。</p>
<ol start="2">
<li>next 数组的求法<br>
数组的值只与模式串有关而与文本串无关，next[i] 的含义为：i 包括 i 之前的子数组的<strong>最大相等前后缀的长度</strong>。这里还需要注意一下：前缀的含义是一个字符串除去最后一个字母之外的所有从第一个字母开始的连续字串，后缀也是差不多的道理。所以比如“aabaa”这个字串的最大相等前后缀就是“aa”，所以其最大相等前后缀长度就是 2；“aaaaa”这个字串的最大相等前后缀是“aaaa”，所以最大相等前后缀长度就是 4。以下是具体代码（C++）:</li>
</ol>
<pre><code class="language-C++">void getNext(int *next, string s) {
    int j = 0;
    next[0] = 0;
    for (int i = 1; i &lt; s.size(); i++) {
        while (j &gt; 0 &amp;&amp; s[i] != s[j]) 
            j = next[j-1];  // 重点语句
        if (s[i] == s[j])
            ++j;
        next[i] = j;
    }
} 
</code></pre>
<p>前面首先对指针和数组进行初始化，重点语句是下面这句，如果新指向字符不匹配，就要重新回到上一个子串（不包含新字符）的最大相等字符长度，然后重新匹配。（这里说的不太清楚，请自行领悟，最好自己在纸上写一下）</p>
<ol start="3">
<li>KMP 算法写法<br>
求出 next 数组之后就好办了，每次匹配到不符合的时候，就找已经匹配完的子串的最大相等前后缀，也就是直接查 next 数组，然后把模式串的指针退回去继续匹配就行了。代码如下：</li>
</ol>
<pre><code class="language-C++">int strStr(string s, string t) {
    if (t.size() == 0)
        return 0;
    int next[t.size()];
    getNext(next, t);
    int j = 0;
    for (int i = 0; i &lt; s.size(); i++) {
        while (j &gt; 0 &amp;&amp; s[i] != t[j]) 
            j = next[j - 1];
        if (s[i] == t[j])
            ++j;
        if (j == t.size())  // 注意这里的判断条件，不是 j == t.size() - 1
            return (i - t.size() + 1);
    }
    return -1;
}
</code></pre>
<p>结束。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历的非递归做法]]></title>
        <id>https://icantnotfindaname.github.io/post/er-cha-shu-bian-li-de-fei-di-gui-zuo-fa/</id>
        <link href="https://icantnotfindaname.github.io/post/er-cha-shu-bian-li-de-fei-di-gui-zuo-fa/">
        </link>
        <updated>2021-09-02T08:51:11.000Z</updated>
        <summary type="html"><![CDATA[<p>树这种结构，天生就适合用递归的做法来遍历，但是递归太容易了，考研不好考呀，没有区分度。于是出题老头们就开始把脑筋动到了非递归做法上。显而易见，能用递归来做那就肯定可以用循环来做，因为递归实际上就是一个栈的应用，我们只要在循环中引入栈就可以使循环达到向递归一样的效果。</p>
]]></summary>
        <content type="html"><![CDATA[<p>树这种结构，天生就适合用递归的做法来遍历，但是递归太容易了，考研不好考呀，没有区分度。于是出题老头们就开始把脑筋动到了非递归做法上。显而易见，能用递归来做那就肯定可以用循环来做，因为递归实际上就是一个栈的应用，我们只要在循环中引入栈就可以使循环达到向递归一样的效果。</p>
<!-- more -->
<p>但是在先、中、后序遍历中，使用循环实现的难度是不一样的，先序遍历和后序遍历会容易一些，但是中序遍历就稍稍有一定的难度了。原因后文再提。</p>
<p>首先看一下先序遍历的非递归写法：</p>
<pre><code class="language-C++">stack&lt;TreeNode*&gt; st;
void traversal_front_(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root == NULL) return; 
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        vec.push_back(node-&gt;val);
        if (node-&gt;right) st.push(node-&gt;right);
        if (node-&gt;left) st.push(node-&gt;left);
    }
}
</code></pre>
<p>首先根节点入栈，然后只要当栈不为空的时候就将栈顶弹出，把栈顶加到结果的 vector 数组中，然后将其左右孩子节点（如果有的话）放入栈中，注意这里有一个顺序问题，首先要入栈的是右节点，因为先进是后出的，我们要保证遍历的顺序是“中左右”。</p>
<p>后序遍历也是类似，不同之处在于我们首先将左孩子节点入栈然后才是右孩子节点，这样才能保证结果数组是按照“先右左”的顺序排列的，于是最后只要将整个数组逆过来，就可以得到后序遍历的正确结果。代码如下：</p>
<pre><code class="language-C++">void traversal_back_(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root == NULL) return;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        vec.push_back(node-&gt;val);
        if (node-&gt;left) st.push(node-&gt;left);
        if (node-&gt;right) st.push(node-&gt;right);
    }
    reverse(vec.begin(), vec.end());
}
</code></pre>
<p>但是中序遍历就没有这么容易的。问题的关键在于，我们在先序遍历和后序遍历中，<strong>待加到结果数组的节点和需要向下遍历的节点是同一个节点</strong>，所以我们用栈就可以同时实现这两个操作，但是在中序遍历中，上述两种操作的对象并不是同一个节点，所以我们就必须使用再加上一个辅助指针，用栈来处理节点，用指针来遍历树。代码如下：</p>
<pre><code class="language-C++">void traversal_mid_(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root == NULL) return;
    TreeNode* cur = root;
    while (cur != NULL || !st.empty()) {
        if (cur != NULL) {
            st.push(cur);
            cur = cur-&gt;left;
        } else {
            cur = st.top();
            st.pop();
            vec.push_back(cur-&gt;val);
            cur = cur-&gt;right;
        }
    }
}
</code></pre>
<p>首先循环条件就变了，只有当指针和栈同时为空的时候才会停止循环。在循环内，当指针不为空的时候，就把指针指向的节点压入栈中，然后将指针指向其左节点；如果指针为空的话，就要把栈顶弹出，加入结果数组中，然后将指针指向其右节点。</p>
<p>但这种写法又有一个问题了：<strong>三种遍历的写法不统一啊！<strong>对于强迫症患者来说，这真是一个天大的噩耗，但并不是没有解决办法的。核心思想是</strong>在已经可以加入结果数组的节点后面插入一个 NULL 节点作为标记</strong>。</p>
<p>于是中序遍历的代码就变成了这样：</p>
<pre><code class="language-C++">void traversal_mid__(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node-&gt;right) st.push(node-&gt;right);
            st.push(node);
            st.push(NULL);  // mark : ready to add to vector `vec` 
            if (node-&gt;left) st.push(node-&gt;left);
        } else {
            st.pop();  // pop the NULL node
            node = st.top();
            st.pop();
            vec.push_back(node-&gt;val);
        }
    }
}
</code></pre>
<p>重点在于注释的那两句，因为 node 已经访问了其左右孩子节点，所以已经可以加入 vec 了，所以插入一个 NULL 节点作为标识。当 node 为 NULL 时，就证明 NULL 的前驱已经准备好进组了，所以首先<strong>把 NULL 节点弹出</strong>（不要忘了这一步），然后把 node 加进结果数组中。</p>
<p>同样的道理，先序遍历和后序遍历也可以用此方法完成，不同的地方就是节点的进栈次序，其他都是一模一样的，代码如下：</p>
<pre><code class="language-C++">void traversal_front__(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node-&gt;right) st.push(node-&gt;right);
            if (node-&gt;left) st.push(node-&gt;left);
            st.push(node);
            st.push(NULL);  // mark : ready to add to vector `vec` 
        } else {
            st.pop();  // pop the NULL node
            node = st.top();
            st.pop();
            vec.push_back(node-&gt;val);
        }
    }
}

void traversal_back__(TreeNode* root, vector&lt;int&gt; &amp;vec) {
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);
            st.push(NULL);  // mark : ready to add to vector `vec`
            if (node-&gt;right) st.push(node-&gt;right);
            if (node-&gt;left) st.push(node-&gt;left);
        } else {
            st.pop();  // pop the NULL node
            node = st.top();
            st.pop();
            vec.push_back(node-&gt;val);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于福柯]]></title>
        <id>https://icantnotfindaname.github.io/post/guan-yu-fu-ke/</id>
        <link href="https://icantnotfindaname.github.io/post/guan-yu-fu-ke/">
        </link>
        <updated>2021-08-30T11:33:21.000Z</updated>
        <summary type="html"><![CDATA[<p>总有一天这会变成一篇完整的，用学术或文学话语铸就的，建立在断壁残垣的思想之上的文本。在福柯处，有一种如在其身的强烈共鸣。</p>
]]></summary>
        <content type="html"><![CDATA[<p>总有一天这会变成一篇完整的，用学术或文学话语铸就的，建立在断壁残垣的思想之上的文本。在福柯处，有一种如在其身的强烈共鸣。</p>
<!-- more -->
<ol>
<li>对于边缘体验的过分追求 ❌ 但是在语言上，在除却身体之外的他处，是有道理的</li>
<li>知识考古学 ⭕</li>
<li>谱系学 这个理论吸引人的地方在于对现存理论话语的冲突，一种难以置信的正确感</li>
<li>权力 —— 在福柯处，本质是一种反抗，知识分子就是要对现有的权力体系进行质疑 —— 无论你是否身在其内。【我说：离经叛道是艺术家的责任，明辨是非是文学家的义务。无论什么时候，这都表现成一种激烈的斗争，一种对少数的体谅和对多数派的本能质疑，一种不间断的反思，无休止的自我扬弃】</li>
<li>人死了 ⭕ 强力的悲观，自尼采一脉相承而来</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[齐泽克: 西方自由主义媒体避而不谈的，塔利班迅速夺回阿富汗的真正原因]]></title>
        <id>https://icantnotfindaname.github.io/post/qi-ze-ke-xi-fang-zi-you-zhu-yi-mei-ti-bi-er-bu-tan-de-ta-li-ban-xun-su-duo-hui-a-fu-han-de-zhen-zheng-yuan-yin/</id>
        <link href="https://icantnotfindaname.github.io/post/qi-ze-ke-xi-fang-zi-you-zhu-yi-mei-ti-bi-er-bu-tan-de-ta-li-ban-xun-su-duo-hui-a-fu-han-de-zhen-zheng-yuan-yin/">
        </link>
        <updated>2021-08-20T05:25:59.000Z</updated>
        <summary type="html"><![CDATA[<p>齐泽克于2021年8月20日在 RT News 上发表了此篇文章，只能说，该来的终究会来。但基本只是老生常谈。</p>
]]></summary>
        <content type="html"><![CDATA[<p>齐泽克于2021年8月20日在 RT News 上发表了此篇文章，只能说，该来的终究会来。但基本只是老生常谈。</p>
<!-- more -->
<p>原文地址：https://www.rt.com/op-ed/532207-zizek-taliban-retake-afghanistan-reason/</p>
<p>以下为本人翻译：</p>
<p>塔利班的8万名士兵重新夺回了阿富汗，城市次第陷落，而披坚执锐的30万政府军却一触即溃，轻易投降。何以至此？</p>
<p>西方媒体告诉我们，对此可以有几种解释。</p>
<p>第一种是公然的种族主义歧视: 阿富汗人民思想不够健全，无力实现民主，只求宗教原教旨主义下的统治——这是个荒谬的主张。半个世纪前，阿富汗还是一个温和开明的国家，拥有一个强大的共产党（即阿富汗人民民主党，该党曾掌权数年），后方才成为宗教原教旨主义国家，这缘自苏联为避免其共产主义力量的崩溃而对阿富汗实行的入侵。</p>
<p>另一种解释是威慑，塔利班逆我者亡的恐怖行径导致无人敢于反抗。</p>
<p>还有一个解释是信仰。 塔利班只相信他们的行为是上帝的旨意，得上帝护佑，也注定会取得胜利，所以他们可以耐心蛰伏，待时而动，因为时间在他们这边。</p>
<p>另一个更加复杂而现实的解释是，不绝的战争和腐败造成的混乱可能会让阿富汗人民相信，即使塔利班政权实施压迫和伊斯兰教法式的统治，也至少可以保障最基本的安全和秩序。</p>
<p>然而，所有这些解释似乎都刻意回避了一个基本事实，这个事实对于自由主义的西方观点来说是创伤性的。这就是塔利班对个人生存的漠视，他们的战士们随时准备“殉教”，以战斗或自杀。塔利班作为原教旨主义者“真诚地相信”，如果他们作为殉道者死去，他们就能进入天堂。但是这种解释并不足够，因为它无法抓住知性洞察力意义上「belief in the sense of intellectual insight」的信仰（“我知道我会上天堂，这是一个事实”）与作为一种主观立场「belief as an engaged subjective position」的信仰之间的区别。</p>
<p>换句话说，<strong>它没有考虑到意识形态的实质力量——在此地是信仰的力量——这不单是信念的力量，而是一种生存论角度上的信仰：我们不作为选择信仰的主体，我们便是信仰，我们的生活浸润在信仰之中。</strong></p>
<p>正是如此，法国哲学家福柯才对1978年的伊斯兰革命情有独钟，这让他两度到访伊朗。让他着迷的不仅仅是乐于接受牺牲和对失去自己的生命漠不关心的立场; 他致力于细致入微地讲述“真相的历史”，强调激进党派与其激烈的真理讲述形式，以斗争和磨难来进行变革，而非现代西方权力那种调和、中立和正常化的形式。理解这种形式的关键在于，历史政治话语中的真理概念本就是一种局部的真理概念，是为党派保留的。</p>
<p>或者，正如福柯所述：</p>
<blockquote>
<p>如果这个主体谈论权利（或者母宁说他们的权利），谈论真理，那么这个真理就不再是哲学上的普遍真理。事实上，这个关于普遍战争的话语，试图从和平的下面分辨出战争的话语，就是要思实地讲述整体的战斗并构筑起战争的通史。但是，它并不就是全体性的或中性的话语；它永远是有视角的话语。仅仅在从它自己的角度出发透视全体性时，才涉及它。也就是说，真理仅仅只能从战斗的阵地出发，从争取胜利出发，可以说是在说话的主体得以幸存的范围内，才能得以展开。—— 《必须保卫社会》钱翰译</p>
</blockquote>
<p>这样一种侵入式的话语能否被视为尚未进入现代个人主义的前现代“原始”社会的标志而被摒弃呢？或者，今日它的复兴是否会被视为法西斯主义回归的标志？</p>
<p>对任何对西方马克思主义有所了解的人而言，答案是显而易见的: 匈牙利哲学家卢卡奇向我们展示了马克思主义是如何“普遍真实”的，不是因为它的不偏不倚，而正是因为它是“片面的”，只能从一个特定的主观立场来理解。我们可能同意或不同意这种观点，但事实是，福柯在遥远的伊朗所寻找的——竞争性的（“战争”）真相说明形式——已经在马克思主义的观点中有力地呈现出来，即，<strong>陷入阶级斗争不是对历史的“客观”知识的障碍，而是它的条件。</strong></p>
<p>通常意义上的实证主义知识，是对现实的一种“客观”（非片面）的方法，它不会被特定的主体参与所扭曲——而福柯所说的“现代西方权力的和谐化、中立化和正常化的形式”——是最纯粹的意识形态——也即“意识形态的终结”。</p>
<p>一方面，我们有非意识形态的“客观”的专家知识；而另一方面，我们分割了个体，使得每个人都专注于自己特有的“自我技术”(福柯放弃伊朗经历时使用的术语) ，沉溺于某些小事给他/她的生活带来的乐趣。</p>
<p>从自由个人主义的主流观点来看，一种普遍的承诺（译者注：我想作者的意思是一种宏观叙事），尤其包括对生命的风险的承诺，都是可疑的、“非理性的”。</p>
<p>在这里，我们遇到了一个有趣的悖论: 虽然传统的马克思主义能否令人信服地解释塔利班的成功奥秘是值得怀疑的，但它提供了福柯在伊朗寻找的东西（以及现在阿富汗令我们着迷的东西）的一个完美的欧洲范例，这个范例并不涉及任何宗教原教旨主义，只是为了更好的生活而进行的一种集体介入。在全球资本主义取得成功之后，这种集体参与的精神就受到了压制，而现在这种压制的立场似乎又在宗教原教旨主义的幌子下回归。</p>
<p>我们能否想象这种精神以一种更适当的，更有解放性的形式回归？当然。不仅可以想象，它已挟巨力敲响了我们的大门。</p>
<p>现在我们来讨论全球变暖这个灾难——它需要大规模的集体行动，需要所有人以某种程度上的殉难形式，牺牲许多我们早已习以为常的享乐。如果我们真的想彻底改变我们的生活方式，那么个人主义这种“自我关心”以获得特定快乐的方式就必须被替代。单靠专家式的科学是无法完成这项任务的——它必须是一门植根于最深刻的集体参与的社会科学。而这个，才是塔利班问题的答案。</p>
<p>( 全文完 )</p>
<h2 id="英文原版">英文原版</h2>
<p>The Taliban’s 80,000 troops have retaken Afghanistan with cities falling like dominos while the 300,000-strong government forces, better equipped and trained, mostly melted and surrendered with no will to fight. Why did it happen?</p>
<p>The Western media tell us there can be several explanations for that. The first one is blatantly racist: the Afghan people there are simply not mature enough for democracy, they long for religious fundamentalism – a ridiculous claim if there ever was one. Half a century ago, Afghanistan was a (moderately) enlightened country with a strong Communist Party known as the People’s Democratic Party of Afghanistan, which even managed to take power for some years. Afghanistan became religiously fundamentalist only later, as a reaction to the Soviet occupation which aimed to prevent the collapse of communist power.</p>
<p>Another explanation the media gives us is terror, as the Taliban ruthlessly executes those who oppose its politics.</p>
<p>A further one is faith: the Taliban simply believe their acts fulfill the task imposed on them by God and their victory is guaranteed. So, they can afford to be patient because time is on their side.</p>
<p>A more complex and realistic explanation as to why the Taliban managed to retake the country so promptly is chaos caused by the ongoing war and corruption. That could have caused a belief that even if the Taliban regime would bring oppression and impose Sharia Law, it would at least guarantee some safety and order.</p>
<p>However, all these explanations seem to avoid a basic fact that is traumatic for the liberal Western view. That is the Taliban’s disregard for survival and the readiness of its fighters to assume “martyrdom,” to die not just in a battle but even in suicidal acts. The explanation that Taliban as fundamentalists “really believe” that they will enter paradise if they die as martyrs is not enough as it fails to capture the difference between belief in the sense of intellectual insight (“I know I will go to heaven, it’s a fact”) and belief as an engaged subjective position.</p>
<p>In other words, it fails to take into account the material power of an ideology – in this case, the power of faith – which is not simply grounded in the strength of our conviction but in how we are existentially committed to our belief: we are not subjects choosing this or that belief, but we “are” our belief in the sense of this belief impregnating our life.</p>
<p>It was due to this feature that French philosopher Michel Foucault was so fascinated by the 1978 Islamic Revolution that he twice visited Iran. What fascinated him there was not just the stance of accepting martyrdom and indifference with regard to losing one’s own life; he was “engaged in a very specific telling of the ‘history of truth’, emphasizing a partisan and agonistic form of truth-telling, and transformation through struggle and ordeal, as opposed to the pacifying, neutralizing, and normalizing forms of modern Western power. Crucial for understanding this point is the conception of truth at work in historico-political discourse, a conception of truth as partial, as reserved for partisans.”</p>
<p>Or, as Foucault himself put it:</p>
<p>“If this subject who speaks of right (or rather, rights) is speaking the truth, that truth is no longer the universal truth of the philosopher. It is true that this discourse about the general war, this discourse that tries to interpret the war beneath peace, is indeed an attempt to describe the battle as a whole and to reconstruct the general course of the war. But that does not make it a totalizing or neutral discourse; it is always a perspectival discourse. It is interested in the totality only to the extent that it can see it in one-sided terms, distort it and see it from its own point of view. The truth is, in other words, a truth that can be deployed only from its combat position, from the perspective of the sought for victory and ultimately, so to speak, of the survival of the speaking subject himself.”</p>
<p>Can such an engaged discourse be dismissed as a sign of premodern “primitive” society which didn’t yet enter modern individualism? And is its revival today to be dismissed as a sign of fascist regression?</p>
<p>To anyone minimally acquainted with Western Marxism, the answer is clear: Hungarian philosopher Georg Lukacs demonstrated how Marxism is “universally true” not in spite of its partiality but because it is “partial,” accessible only from a particular subjective position. We may agree or disagree with this view, but the fact is that what Foucault was looking for in far-away Iran – the agonistic (“war”) form of truth-telling – was already forcefully present in the Marxist view that being caught in the class struggle is not an obstacle to “objective” knowledge of history but its condition.</p>
<p>The usual positivist notion of knowledge as an “objective” (non-partial) approach to reality which is not distorted by a particular subjective engagement – what Foucault characterized as “the pacifying, neutralizing, and normalizing forms of modern Western power” – is ideology at its purest – the ideology of the “end of ideology.”</p>
<p>On the one hand, we have non-ideological “objective” expert-knowledge. On the other hand, we have dispersed individuals, each of whom is focused on his/her idiosyncratic “care of the self” (the term Foucault used when he abandoned his Iranian experience), small things that bring pleasure to his/her life.</p>
<p>From this standpoint of liberal individualism, and universal commitment, especially if it includes risk of life, is suspicious and “irrational”…</p>
<p>Here we encounter an interesting paradox: while it is doubtful that traditional Marxism can provide a convincing account of the success of Taliban, it provided a perfect European example of what Foucault was looking for in Iran (and of what fascinates us now in Afghanistan), an example which did not involve any religious fundamentalism but just a collective engagement for a better life. After the triumph of global capitalism, this spirit of collective engagement was repressed, and now this repressed stance seems to return in the guise of religious fundamentalism.</p>
<p>Can we imagine a return of the repressed in its proper form of collective emancipatory engagement? Indeed. Not only can we imagine it, it is already knocking on our doors with great force.</p>
<p>Let’s just mention the global warming catastrophe – it calls for large-scale collective actions which will demand their own forms of martyrdom, sacrificing many pleasures we have got used to. If we really want to change our entire way of life, the individualist “care of the self” which focuses on our use of pleasures will have to be superseded. Expert science alone will not do the job – it will have to be a science rooted in the deepest collective engagement. THIS should be our answer to the Taliban.</p>
<p>( End )</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[齐泽克：分析哲学 vs 欧陆哲学]]></title>
        <id>https://icantnotfindaname.github.io/post/qi-ze-ke-fen-xi-zhe-xue-vs-ou-lu-zhe-xue/</id>
        <link href="https://icantnotfindaname.github.io/post/qi-ze-ke-fen-xi-zhe-xue-vs-ou-lu-zhe-xue/">
        </link>
        <updated>2021-08-20T03:55:34.000Z</updated>
        <summary type="html"><![CDATA[<p>对我而言，更为感兴趣的一点是齐泽克在视频后半部分提出的有趣观点：<strong>现实是未完成的</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>对我而言，更为感兴趣的一点是齐泽克在视频后半部分提出的有趣观点：<strong>现实是未完成的</strong>。</p>
<!-- more -->
<p>视频地址：https://www.bilibili.com/video/BV17341167ur?share_source=copy_web</p>
<iframe src="//player.bilibili.com/player.html?aid=419940997&bvid=BV17341167ur&cid=392866033&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何看懂生肉？]]></title>
        <id>https://icantnotfindaname.github.io/post/ru-he-kan-dong-sheng-rou/</id>
        <link href="https://icantnotfindaname.github.io/post/ru-he-kan-dong-sheng-rou/">
        </link>
        <updated>2021-08-19T02:42:44.000Z</updated>
        <summary type="html"><![CDATA[<p>这个短视频给了一个很简单有效的方法提升听力，但是我找不到原视频的地址了，文中提供的来源为tg群：黑洞资源笔记......</p>
]]></summary>
        <content type="html"><![CDATA[<p>这个短视频给了一个很简单有效的方法提升听力，但是我找不到原视频的地址了，文中提供的来源为tg群：黑洞资源笔记......</p>
<!-- more -->
<p>在开始的时候，务必从一些简单难度的音频开始，接着逐渐加大难度，（如果难度过大，试着调低倍速）。当你发现你可以很轻松地听完整段材料时，不要满足于此，接着调高倍速进行练习。（可以听懂两倍速个人觉得就差不多了）</p>
<p>视频地址：https://t.me/tieliu/14572</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nextcloud 安装笔记]]></title>
        <id>https://icantnotfindaname.github.io/post/nextcloud-an-zhuang-bi-ji/</id>
        <link href="https://icantnotfindaname.github.io/post/nextcloud-an-zhuang-bi-ji/">
        </link>
        <updated>2021-08-18T02:41:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Nextcloud是ownCloud的创始人Frank Karlitschek创建的一个分支，他与原先ownCloud的一些团队成员继续开发Nextcloud，同时也成立了一家商业化公司，其目标就是将数据和通讯的控制权归还给用户。直到2019年初，Nextcloud已成为最受欢迎的私有云盘之一（下图所示）。与此同时，也有越来越多的开发者涌入社区，为Nextcloud开发了许多的应用插件......</p>
]]></summary>
        <content type="html"><![CDATA[<p>Nextcloud是ownCloud的创始人Frank Karlitschek创建的一个分支，他与原先ownCloud的一些团队成员继续开发Nextcloud，同时也成立了一家商业化公司，其目标就是将数据和通讯的控制权归还给用户。直到2019年初，Nextcloud已成为最受欢迎的私有云盘之一（下图所示）。与此同时，也有越来越多的开发者涌入社区，为Nextcloud开发了许多的应用插件......</p>
<!-- more -->
<p>Snap 是一个类似容器的东西，支持 CentOS7.6+，其他系统可以到 snap 的官网进行查看。</p>
<p><a href="https://snapcraft.io/install/nextcloud/centos">Install Nextcloud on CentOS using the Snap Store | Snapcraft</a></p>
<p>下载命令如下：</p>
<pre><code class="language-bash">sudo yum install epel-release
sudo yum install snapd
sudo systemctl enable --now snapd.socket
sudo ln -s /var/lib/snapd/snap /snap
sudo snap install nextcloud

// 以上已经下载完成
// 换端口
snap set nextcloud ports.http=60000

// https 配置SSL
nextcloud.enable-https lets-encrypt

// 创建软连接
ln -s /var/snap/nextcloud/common/nextcloud/data/louis/files /root/nextcloud
</code></pre>
<p>一些其他的命令可以查看官方 Github，可以解决 80% 的问题：</p>
<p><a href="https://github.com/nextcloud/nextcloud-snap">GitHub - nextcloud/nextcloud-snap: ☁️📦 Nextcloud packaged as a snap</a></p>
<p>或者官方文档：</p>
<p><a href="https://docs.nextcloud.com/server/latest/admin_manual/installation/#installation">Installation and server configuration - Nextcloud latest Administration Manual latest documentation</a></p>
<hr>
<p>2021.08.23 Update<br>
如果在服务器直接上传文件到 nextcloud 的 data 目录下，则需要手动扫描才可以在 web 上看到更新内容，推荐方法如下：</p>
<pre><code class="language-bash">vi /var/snap/nextcloud/28417/nextcloud/config/config.php  // 配置文件路径请自行确定

// 在最后一行添加
'filesystem_check_changes' =&gt; true,
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Net-Speeder 加速]]></title>
        <id>https://icantnotfindaname.github.io/post/net-speeder-jia-su/</id>
        <link href="https://icantnotfindaname.github.io/post/net-speeder-jia-su/">
        </link>
        <updated>2021-08-07T02:38:09.000Z</updated>
        <summary type="html"><![CDATA[<p>注：开启了net-speeder的服务器上对外ping时看到的是4倍，实际网络上是2倍流量。另外两倍是内部dup出来的，不占用带宽。 另外，内部dup包并非是偷懒未判断，是为了更快触发快速重传的。同时，net-speeder不依赖ttl的大小，ttl的大小跟流量无比例关系。不存在windows的ttl大，发包就多的情况。</p>
]]></summary>
        <content type="html"><![CDATA[<p>注：开启了net-speeder的服务器上对外ping时看到的是4倍，实际网络上是2倍流量。另外两倍是内部dup出来的，不占用带宽。 另外，内部dup包并非是偷懒未判断，是为了更快触发快速重传的。同时，net-speeder不依赖ttl的大小，ttl的大小跟流量无比例关系。不存在windows的ttl大，发包就多的情况。</p>
<!-- more -->
<h2 id="1-prepare">1. Prepare</h2>
<pre><code class="language-json">yum -y install gcc  // install gcc
gcc --version  // check 
yum install libnet libpcap libnet-devel libpcap-devel
</code></pre>
<h2 id="2-install">2. Install</h2>
<pre><code class="language-json">wget https://github.com/snooda/net-speeder/archive/master.zip
unzip master.zip
rm -rf master.zip
cd net-speeder-master/ 
sh build.sh
</code></pre>
<h2 id="3-usage">3. Usage</h2>
<pre><code class="language-json">// 给所有的ip协议加速
nohup /usr/local/net_speeder/net_speeder eth0 &quot;ip&quot; &gt;/dev/null 2&gt;&amp;1 &amp;
</code></pre>
<h2 id="4-result">4. Result</h2>
<p>下行速度翻了个倍，但是上行速度没有显著提升，甚至有所下降。</p>
<hr>
<h3 id="20210807-update">2021.08.07 Update</h3>
<p>晚高峰时速度大致提升20%，但这种技术终归是损人利己，还是关了罢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有关Netflix解锁的说明]]></title>
        <id>https://icantnotfindaname.github.io/post/you-guan-netflix-jie-suo-de-shuo-ming/</id>
        <link href="https://icantnotfindaname.github.io/post/you-guan-netflix-jie-suo-de-shuo-ming/">
        </link>
        <updated>2021-08-06T02:36:46.000Z</updated>
        <summary type="html"><![CDATA[<p>今天6时许，有网友发现，大量此前能够观看非 Netflix 版权资源的代理 IP 已不起作用。包括腾讯云101、绿云195，阿里云161、Cloudflare WARP 等大量此前能够解锁的 IP 受到影响。Netflix 自制剧可以正常观赏......</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天6时许，有网友发现，大量此前能够观看非 Netflix 版权资源的代理 IP 已不起作用。包括腾讯云101、绿云195，阿里云161、Cloudflare WARP 等大量此前能够解锁的 IP 受到影响。Netflix 自制剧可以正常观赏......</p>
<!-- more -->
<p>以下文章来源：</p>
<p><a href="https://t.me/KuaiCheDao_Info/1683">香港 台灣 新加坡 美國 IDC 資源 - 快車道</a></p>
<p><strong>正文：</strong></p>
<p>2021年8月4日早上開始，Netflix（以下簡稱 NF ）封鎖了大量IP和IP段。被封的現象是只能觀看帶有 N 字標記的 NF 自製節目；從版權方外購的節目無法觀賞。</p>
<p>被封鎖的 IP 包<br>
⁃ 數據中心 IP 段<br>
⁃ 商業寬頻 IP 段<br>
⁃ 單個 IP</p>
<p>事情發生後，快車道群裡面出現了大量關於本次封鎖的討論。有人說是用了 IPInfo 的數據庫，有人說是用了 MaxMind 數據庫，也有大機場老闆反饋新換上去的家寬 IP 很快就被鎖定。</p>
<p>能夠在幾個小時內把原來能用的家庭寬帶IP地址，快速識別，並列入黑名單，這不是 IP 數據庫能做到的。畢竟，IP數據庫的更新一般以周為單位。據我們了解，NF檢測 Proxy 的算法其實已經成熟很久了，加之<br>
NF 能夠記錄到客戶帳戶訪問 Log ，可以用比 IP 數據庫更多的原始信息來檢測 Proxy 。所以，我們推測，這是 NF 自己幹的。</p>
<p>但是，NF 為什麼要這樣做就頗為讓人費解。主要有 2 個可能。</p>
<ol>
<li>版權方逼迫。不太可能。因為 NF 按照播放次數和時長，與外部版權方結算。看的人越多，播放次數越多，版權方收益越大。從經濟上說，版權方不可能去斷自己財路。</li>
<li>NF 自發。這個比較可能。NF 的一部分盈利就來自於客戶買帳戶的月費超出付給版權方的實際播放結算費。發達經濟體中客戶時薪高，帳戶月費高，相對觀看時間較短，所以是一個划算的生意。反之，一個中國大陸客戶，買了土耳其、印度、阿根廷、巴西區的低價帳戶，再通過 Proxy 來觀看單次點播結算價格高的版權內容，那就是虧本買賣啦。</li>
</ol>
<p>如何解鎖？</p>
<ol>
<li>動態IP VPS輪作。2台動態IP家庭寬帶 VM，第1個小時走 VM-1 出；第2個小時走 VM-2，並刷新 VM-1 的IP地址；第3個小時再切換回已獲得新IP的 VM-1，並刷新 VM-2 的IP，為下個小時做準備。這樣做的機場如果很多的話，肯出現大量IP被封，電訊商和 NF 都將喜提一堆投訴。</li>
<li>IPv6子網雪鞋。獲得一個 /64 的 IPv6 子網。將每一個 Proxy 用戶唯一地散列映射到一個 IPv6 地址，避免所有客戶登入 NF 都走同一個 IP 地址。這樣做的問題是：(A) 代理程序需要修改，對不同客戶帳戶用不同的出口 IPv6 地址；(B) DNS 解鎖的機場客戶不適用，機場節點轉至 SNI Proxy 的流量無法區分客戶帳戶；(C) NF 可以輕易修改算法封鎖，將 IPv6 /64 子網視為同一IP地址即可。</li>
</ol>
<p>快車道態度：躺平了舒服，別反抗，不要去和算法拼手速。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[京东自动签到脚本部署]]></title>
        <id>https://icantnotfindaname.github.io/post/jing-dong-qian-dao/</id>
        <link href="https://icantnotfindaname.github.io/post/jing-dong-qian-dao/">
        </link>
        <updated>2021-08-05T15:41:32.000Z</updated>
        <summary type="html"><![CDATA[<p>每天撸它个一百豆，就当交服务器的钱了。脚本基于青龙面板以及Ninja，不过没有使用互助池等更高级的配置......</p>
]]></summary>
        <content type="html"><![CDATA[<p>每天撸它个一百豆，就当交服务器的钱了。脚本基于青龙面板以及Ninja，不过没有使用互助池等更高级的配置......</p>
<!-- more -->
<h2 id="1-准备">1. 准备</h2>
<p>一台 Linux 服务器（最好是 centos 系统），京东账号关闭免密支付、打开支付验密设置并修改过于精确的地址以防万一。</p>
<h2 id="2-安装docker">2. 安装Docker</h2>
<pre><code class="language-bash">sudo yum check-update
curl -fsSL https://get.docker.com/ | sh
sudo systemctl start docker
sudo systemctl status docker
sudo systemctl enable docker
</code></pre>
<h2 id="3-安装青龙面板">3. 安装青龙面板</h2>
<pre><code class="language-bash">docker run -dit \
  -v /ql/config:/ql/config \
  -v /ql/log:/ql/log \
  -v /ql/db:/ql/db \
  -v /ql/repo:/ql/repo \
  -v /ql/raw:/ql/raw \
  -v /ql/scripts:/ql/scripts \
  -v /ql/jbot:/ql/jbot \
  -v /ql/ninja:/ql/ninja \
  -p 5700:5700 \
  -p 5701:5701 \
  --name qinglong \
  --hostname qinglong \
  --restart unless-stopped \
  whyour/qinglong:latest
</code></pre>
<p>如果你的服务器开启了防火墙，还需要放行 <code>5700</code> 和 <code>5701</code> 端口。</p>
<p>接着打开 <code>ip:5700</code> 就可以访问面板了，默认用户名密码都是 <code>admin</code> 。登录之后会提示你修改密码，使用下面的指令打开配置文件：</p>
<pre><code class="language-bash">vi /ql/config/auth.json
</code></pre>
<p>修改成你自己想要的用户名和密码。接着重新登录到面板，添加签到仓库如下：</p>
<pre><code class="language-bash">// 更新longzhuzhu仓库
ql repo https://ghproxy.com/https://github.com/nianyuguai/longzhuzhu.git &quot;qx&quot;

// 更新i-chenzi仓库
ql repo https://ghproxy.com/https://github.com/monk-coder/dust.git &quot;i-chenzhe|normal|member|car&quot; &quot;backup&quot;

// 更新lxk仓库
ql repo https://ghproxy.com/https://github.com/chinnkarahoi/jd_scripts.git &quot;jd_|jx_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER&quot;

// 更新whyour仓库
ql repo https://ghproxy.com/https://github.com/whyour/hundun.git &quot;quanx&quot; &quot;tokens|caiyun|didi|donate|fold|Env&quot;
</code></pre>
<h2 id="4-安装-ninja">4. 安装 Ninja</h2>
<p>执行以下命令即可安装。</p>
<pre><code class="language-bash">sudo docker exec -it qinglong bash ## 进入青龙容器，qinglong为容器名称，根据自己
git clone https://github.com/MoonBegonia/ninja.git /ql/ninja ## 拉取ninja 
cd /ql/ninja/backend ## 进入ninja后端文件夹
pnpm install ## 安装ninja
pm2 start ## 启动ninja
</code></pre>
<h2 id="5-配置面板">5. 配置面板</h2>
<p>首先添加启动任务到 <code>extra.sh</code> ，脚本内容如下：</p>
<pre><code class="language-bash">cd /ql/ninja/backend
pm2 start
</code></pre>
<p>接着在浏览器里输入 <code>ip:5701</code> 访问 Ninja 面板，使用京东扫码登录账号之后就可以在青龙面板的环境变量里查看到自己的 cookie。</p>
<p>最后手动执行一下一开始创建的四个任务，（可能会失败，但只要有一个成功就可以了），然后刷新一下面板页面，就会发现任务栏里多了很多京东的自动执行任务，到这里就说明已经配置成功了。</p>
<hr>
<h3 id="20210806-update">2021.08.06 Update</h3>
<p>查看日志的时候发现某些脚本有运行错误，于是找了一个库网站，可以换个源试试：</p>
<p><a href="https://www.kejiwanjia.com/notes/4839.html">常用的库集锦（8.4新增yuannian1112） - 科技玩家</a></p>
<p>还有一些错误是因为缺少依赖库引起的，VPS进入对应的容器里面添加一下依赖库就可以了。</p>
]]></content>
    </entry>
</feed>